package edu.cmu.cs.ls.keymaerax.btactics

import java.io.{File, FileWriter}

import edu.cmu.cs.ls.keymaerax.Configuration
import edu.cmu.cs.ls.keymaerax.bellerophon.BelleProvable
import edu.cmu.cs.ls.keymaerax.btactics.DerivedAxioms._
import edu.cmu.cs.ls.keymaerax.core.{Lemma, Sequent}
import edu.cmu.cs.ls.keymaerax.lemma.LemmaDBFactory
import edu.cmu.cs.ls.keymaerax.tags.{CheckinTest, IgnoreInBuildTest, SummaryTest, UsualTest}
import testHelper.KeYmaeraXTestTags
import testHelper.KeYmaeraXTestTags.OptimisticTest
import edu.cmu.cs.ls.keymaerax.parser.StringConverter._
import edu.cmu.cs.ls.keymaerax.pt.ProvableSig

import scala.collection.immutable

/**
 * Tests [[edu.cmu.cs.ls.keymaerax.btactics.DerivedAxioms]]
  * @see [[CodeNameChecker]]
 */
@CheckinTest
@SummaryTest
@UsualTest
@IgnoreInBuildTest // otherwise it deletes derived lemmas while other tests are running
class DerivedAxiomsTests extends edu.cmu.cs.ls.keymaerax.btactics.TacticTestBase {

  private def check(lemma: Lemma): Sequent = {
    println(lemma.name.get + "\n" + lemma.fact.conclusion)
    lemma.fact shouldBe 'proved
    useToClose(lemma)
    lemma.fact.conclusion
  }

  private def useToClose(lemma: Lemma): Unit = {
    ProvableSig.startProof(lemma.fact.conclusion)(lemma.fact, 0) shouldBe 'proved
    //@note same test as previous line, just to make sure the lemma can be used by substitution
    theInterpreter(TactixLibrary.byUS(lemma), BelleProvable(ProvableSig.startProof(lemma.fact.conclusion))) match {
      case BelleProvable(provable, _) => provable shouldBe 'proved
      case _ => fail()
    }
  }

  "The DerivedAxioms prepopulation procedure" should "not crash" taggedAs KeYmaeraXTestTags.CheckinTest in withMathematica { qeTool =>
    DerivedAxioms.prepopulateDerivedLemmaDatabase()
    val cache = new File(Configuration.path(Configuration.Keys.LEMMA_CACHE_PATH))
    val versionFile = new File(cache.getAbsolutePath + File.separator + "VERSION")
    if (!versionFile.exists()) {
      if (!versionFile.createNewFile()) throw new Exception(s"Could not create ${versionFile.getAbsolutePath}")
    }
    assert(versionFile.exists())
    val fw = new FileWriter(versionFile)
    fw.write(edu.cmu.cs.ls.keymaerax.core.VERSION)
    fw.close()
  }

  "Derived Rule" should "prove allG" in withMathematica { qeTool => allGeneralize.fact.subgoals shouldBe List(
    Sequent(immutable.IndexedSeq(), immutable.IndexedSeq("p_(||)".asFormula))
  ) }

  it should "prove Goedel" in withMathematica { qeTool => Goedel.fact.subgoals shouldBe List(
    Sequent(immutable.IndexedSeq(), immutable.IndexedSeq("p_(||)".asFormula))
  ) }

  it should "prove CT" in withMathematica { qeTool => CTtermCongruence.fact.subgoals shouldBe List(
    Sequent(immutable.IndexedSeq(), immutable.IndexedSeq("f_(||) = g_(||)".asFormula))
  ) }

  it should "prove [] monotone" in withMathematica { qeTool => boxMonotone.fact.subgoals shouldBe List(
    Sequent(immutable.IndexedSeq("p_(||)".asFormula), immutable.IndexedSeq("q_(||)".asFormula))
  ) }

  it should "prove [] monotone 2" in withMathematica { qeTool => boxMonotone2.fact.subgoals shouldBe List(
    Sequent(immutable.IndexedSeq("q_(||)".asFormula), immutable.IndexedSeq("p_(||)".asFormula))
  ) }

  it should "prove con convergence flat" in withMathematica { qeTool => convergenceFlat.fact.subgoals shouldBe List(
    //Sequent(immutable.IndexedSeq("v_<=0".asFormula, "J(||)".asFormula), immutable.IndexedSeq("p_(||)".asFormula)),
    Sequent(immutable.IndexedSeq("\\exists x_ (x_<=0 & J(||))".asFormula), immutable.IndexedSeq("p_(||)".asFormula)),
    Sequent(immutable.IndexedSeq("x_>0".asFormula, "J(||)".asFormula), immutable.IndexedSeq("<a_{|x_|};><x_:=x_-1;>J(||)".asFormula))
  ) }

  "Derived Axioms" should "prove <-> reflexive" in {check(equivReflexiveAxiom)}
  it should "prove !!" in {check(doubleNegationAxiom)}
  it should "prove exists dual" in {check(existsDualAxiom)}
  it should "prove all eliminate" taggedAs OptimisticTest ignore {check(allEliminateAxiom)}
  it should "prove exists eliminate" taggedAs OptimisticTest ignore {check(existsEliminate)}
  it should "prove !exists" in {check(notExists)}
  it should "prove !all" in {check(notAll)}
//  it should "prove !all2" in {check(notAll2)}
  it should "prove ![]" in {check(notBox)}
  it should "prove !<>" in {check(notDiamond)}
  it should "prove all distribute" ignore {check(allDistributeAxiom)}
  it should "prove box dual" in {check(boxAxiom)}
  it should "prove V vacuous" in {check(vacuousAxiom)}
//  it should "prove K1" in {check(K1)}
//  it should "prove K2" in {check(K2)}
  //@todo nrf it should "prove box split" in {check(boxAnd)}
//  it should "prove box split left" in {check(boxSplitLeft)}
//  it should "prove box split right" in {check(boxSplitRight)}
  it should "prove [] split" in {check(boxAnd)}
  it should "prove [] conditional split" in {check(boxImpliesAnd)}
  it should "prove <> split" in {check(diamondOr)}
  it should "prove []~><> propagation" in {check{boxDiamondPropagation}}
  it should "prove <:=> assign" in {check(assigndAxiom)}
//  it should "prove <:=> assign v" in {check(dummyassigndVvariant)}
  it should "prove := assign dual" in {check(assignDualAxiom)}
  it should "prove all substitute" in withMathematica { qeTool => check(allSubstitute)}
  it should "prove [:=] equational" in withMathematica { qeTool => check(assignbEquationalAxiom)}
//  it should "prove [:=] assign equality exists" in {check(assignbExistsAxiom)}
  it should "prove exists and" in {check(existsAndAxiom)}
  it should "prove [:=] assign exists" in {check(assignbImpliesExistsAxiom)}
  it should "prove <:=> assign equality" in {check(assigndEqualityAxiom)}
  it should "prove <:=> assign dual 2" in {check(assignDual2Axiom)}
  it should "prove <:=> assign equality all" in {check(assigndEqualityAllAxiom)}
  it should "prove [:=] vacuous assign" in {check(vacuousAssignbAxiom)}
  it should "prove <:=> vacuous assign" in {check(vacuousAssigndAxiom)}
  //@todo it should "prove [':=] differential assign" in {check(assignDAxiomb)}
  it should "prove <':=> differential assign" in {check(assignDAxiom)}
  it should "prove <:*> assign nondet" in {check(nondetassigndAxiom)}
  it should "prove <?> test" in {check(testdAxiom)}
  it should "prove <++> choice" in {check(choicedAxiom)}
  it should "prove <;> compose" in {check(composedAxiom)}
  it should "prove <*> iterate" in {check(iteratedAxiom)}
  it should "prove <*> approx" in {check(loopApproxd)}
  it should "prove [*] approx" in {check(loopApproxb)}
  it should "prove II induction" in {check(iiinduction)}
  it should "prove [*] merge" in {check(loopMergeb)}
  it should "prove <*> merge" in {check(loopMerged)}
  it should "prove [**] iterate iterate" in {check(iterateiterateb)}
  it should "prove <**> iterate iterate" in {check(iterateiterated)}
  it should "prove [*-] backiterate sufficiency" in {check(backiteratebsuff)}
  it should "prove [*-] backiterate necessity" in {check(backiteratebnecc)}
  it should "prove [*-] backiterate" in {check(backiterateb)}
  it should "prove Ieq induction" in {check(Ieq)}
  it should "prove [d] dual" in {check(dualbAxiom)}
  it should "prove [d] dual direct" in {check(dualbDirectAxiom)}
  it should "prove <d> dual direct" in {check(dualdDirectAxiom)}
  it should "prove exists generalize" in {check(existsGeneralize)}
  it should "prove vacuous exists" in {check(vacuousExistsAxiom)}
  it should "prove V[:*] vacuous assign nondet" in {check(vacuousBoxAssignNondetAxiom)}
  it should "prove V<:*> vacuous assign nondet" in {check(vacuousDiamondAssignNondetAxiom)}
  it should "prove & commute" in {check(andCommute)}
  it should "prove & assoc" in {check(andAssoc)}
  it should "prove !& deMorgan" in {check(notAnd)}
  it should "prove !| deMorgan" in {check(notOr)}
  it should "prove !-> deMorgan" in {check(notImply)}
  it should "prove !<-> deMorgan" in {check(notEquiv)}
  it should "prove -> converse" in {check(converseImply)}
  it should "prove domain commute" in {check(domainCommute)}
  it should "prove -> expand" in {check(implyExpand)}
  it should "prove Kd diamond modus ponens" in {check(KdAxiom)}
  it should "prove Kd2 diamond modus ponens" in {check(Kd2Axiom)}
  it should "prove PC1" in {check(PC1)}
  it should "prove PC2" in {check(PC2)}
  it should "prove PC3" in {check(PC3)}
  it should "prove -> tautology" in {check{implyTautology}}
  it should "prove ->'" in {check(Dimply)}
  it should "prove \\forall->\\exists" in {check(forallThenExistsAxiom)}
  //it should "prove DI differential invariance from DI" in {check(DIinvariance)}
  /** 15624 */
  it should "prove DAI differential invariant from DAI" in {check(DAIinvariant)}
  it should "prove DAC differential cut from DAC" in {check(DADiffCut)}

  it should "prove DI differential invariant from DI" in {check(DIinvariant)}
  it should "prove DIo open differential invariance <" in {check(DIOpeninvariantLess)}
  it should "prove DV differential variant <=" in withMathematica {qeTool => check(DVLessEqual)}
  it should "prove DW differential weakening" in {check(DWeakening)}
  it should "prove DW differential weakening and" in {check(DWeakeningAnd)}
  it should "prove DR differential refine" in {check(DiffRefine)}
  it should "prove DC differential cut" in {check(DiffCut)}
  it should "prove DS no domain" in {check(DSnodomain)}
  it should "prove Dsol& differential equation solution" in {check(DSddomain)}
  it should "prove DGd differential ghost" in {check(DGddifferentialghost)}
  it should "prove DGCd diamond differential ghost const" in {check(DGCddifferentialghostconst)}
  it should "prove DGCd diamond differential ghost const exists" in {check(DGCddifferentialghostconstexists)}
  it should "prove DCd diamond differential cut" in {check(DCddifferentialcut)}
  it should "prove DWd diamond differential weakening" in {check(DWddifferentialweakening)}
  it should "prove DWd2 diamond differential weakening" in {check(DWd2differentialweakening)}
  it should "prove comma commute diamond" in {check(commaCommuted)}
  it should "prove DGd diamond inverse differential ghost implicational" in {check(DGdinversedifferentialghostimplicational)}
  //  it should "prove x' derive var" in {check(Dvar)}
  it should "prove x' derive variable" in {check(Dvariable)}
  it should "prove x' derive var commuted" in withMathematica { qetool => check(DvariableCommuted)}
  it should "prove 'linear" in withMathematica { qetool => check(Dlinear)}
  it should "prove 'linear right" in withMathematica { qeTool => check(DlinearRight)}
  it should "prove DG differential pre-ghost" in {check(DGpreghost)}
  it should "prove DX diamond differential skip" in {check(Dskipd)}
  it should "prove 0*" in withMathematica { qeTool => check(zeroTimes)}
  it should "prove 0+" in withMathematica { qeTool => check(zeroPlus)}
  it should "prove +0" in withMathematica { qeTool => check(plusZero)}
  it should "prove *0" in withMathematica { qeTool => check(timesZero)}
  it should "prove = reflexive" in withMathematica {qetool =>check(equalReflex)}
  it should "prove = commute" in withMathematica { qetool =>check(equalCommute)}
  it should "prove <=" in withMathematica { qetool =>check(lessEqual)}
  it should "prove ! !=" in withMathematica { qetool =>check(notNotEqual)}
  it should "prove >= flip" in withMathematica { qetool =>check(flipGreaterEqual)}
  it should "prove > flip" in withMathematica { qetool =>check(flipGreater)}
  it should "prove <= flip" in withMathematica { qetool =>check(flipLessEqual)}
  it should "prove < flip" in withMathematica { qetool =>check(flipLess)}
  it should "prove + associative" in withMathematica { qeTool => check(plusAssociative)}
  it should "prove * associative" in withMathematica { qeTool => check(timesAssociative)}
  it should "prove + commute" in withMathematica { qeTool => check(plusCommutative)}
  it should "prove * commute" in withMathematica { qeTool => check(timesCommutative)}
  it should "prove distributive" in withMathematica { qeTool => check(distributive)}
  it should "prove + identity" in withMathematica { qeTool => check(plusIdentity)}
  it should "prove * identity" in withMathematica { qeTool => check(timesIdentity)}
  it should "prove + inverse" in withMathematica { qeTool => check(plusInverse)}
  it should "prove * inverse" in withMathematica { qeTool => check(timesInverse)}
  it should "prove positivity" in withMathematica { qeTool => check(positivity)}
  it should "prove + closed" in withMathematica { qeTool => check(plusClosed)}
  it should "prove * closed" in withMathematica { qeTool => check(timesClosed)}
  it should "prove <" in withMathematica { qeTool => check(less)}
  it should "prove ! <" in withMathematica { qeTool => check(notLess)}
  it should "prove ! <=" in withMathematica { qeTool => check(notLessEqual)}
  it should "prove >" in withMathematica { qeTool => check(greater)}
  it should "prove ! >" in withMathematica { qeTool => check(notGreater)}
  it should "prove ! >=" in withMathematica { qeTool => check(notGreaterEqual)}

//  it should "prove != elimination" in withMathematica { qeTool => check(notEqualElim)}
//  it should "prove >= elimination" in withMathematica { qeTool => check(greaterEqualElim)}
//  it should "prove > elimination" in withMathematica { qeTool => check(greaterElim)}
  it should "prove 1>0" in withMathematica { qeTool => check(oneGreaterZero)}
  it should "prove nonnegative squares" in withMathematica { qeTool => check(nonnegativeSquares)}
  it should "prove >2!=" in withMathematica { qeTool => check(greaterImpliesNotEqual)}
  it should "prove > monotone" in withMathematica { qeTool => check(greaterMonotone)}

  it should "prove abs" in withMathematica { qeTool => check(absDef)}
  it should "prove min" in withMathematica { qeTool => check(minDef)}
  it should "prove max" in withMathematica { qeTool => check(maxDef)}
  it should "prove & recusor" in withMathematica { qeTool => check(andRecursor)}
  it should "prove | recursor" in withMathematica { qeTool => check(orRecursor)}
  it should "prove <= both" in withMathematica { qeTool => check(intervalLEBoth)}
  it should "prove < both" in withMathematica { qeTool => check(intervalLBoth)}
  it should "prove neg<= up" in withMathematica { qeTool => check(intervalUpNeg)}
  it should "prove abs<= up" in withMathematica { qeTool => check(intervalUpAbs)}
  it should "prove max<= up" in withMathematica { qeTool => check(intervalUpMax)}
  it should "prove min<= up" in withMathematica { qeTool => check(intervalUpMin)}
  it should "prove +<= up" in withMathematica { qeTool => check(intervalUpPlus)}
  it should "prove -<= up" in withMathematica { qeTool => check(intervalUpMinus)}
  it should "prove *<= up" in withMathematica { qeTool => check(intervalUpTimes)}
  it should "prove pow<= up" in withMathematica { qeTool => check(intervalUpPower)}
  it should "prove 1Div<= up" in withMathematica { qeTool => check(intervalUp1Divide)}
  it should "prove <=+ down" in withMathematica { qeTool => check(intervalDownPlus)}
  it should "prove <=- down" in withMathematica { qeTool => check(intervalDownMinus)}
  it should "prove <=* down" in withMathematica { qeTool => check(intervalDownTimes)}
  it should "prove <=pow down" in withMathematica { qeTool => check(intervalDownPower)}
  it should "prove <=1Div down" in withMathematica { qeTool => check(intervalDown1Divide)}
  it should "prove K& down" in withMathematica { qeTool => check(Kand)}
  it should "prove &-> down" in withMathematica { qeTool => check(andImplies)}
  it should "prove <= & <=" in withMathematica { qeTool => check(metricAndLe)}
  it should "prove < & <" in withMathematica { qeTool => check(metricAndLt)}
  it should "prove <= | <=" in withMathematica { qeTool => check(metricOrLe)}
  it should "prove < | <" in withMathematica { qeTool => check(metricOrLt)}

  "Derived Axiom Tactics" should "tactically prove <-> reflexive" in {check(equivReflexiveAxiom)}
  it should "tactically prove !!" in {check(doubleNegationAxiom)}
  it should "tactically prove exists dual" in {check(existsDualAxiom)}
  it should "tactically prove all eliminate" taggedAs OptimisticTest ignore {check(allEliminateAxiom)}
  it should "tactically prove exists eliminate" in {check(existsEliminate)}
  it should "tactically prove all distribute" in {check(allDistributeAxiom)}
  it should "tactically prove box dual" in {check(boxAxiom)}
  it should "tactically prove <:=> assign" in {check(assigndAxiom)}
  it should "tactically prove [:=] equational" in withMathematica { qeTool => check(assignbEquationalAxiom)}
//  it should "tactically prove [:=] equational exists" in {check(assignbExistsAxiom, assignbEquationalT)}
  it should "tactically prove [:=] vacuous assign" in {check(vacuousAssignbAxiom)}
  it should "tactically prove <:=> vacuous assign" in {check(vacuousAssigndAxiom)}
  it should "tactically prove <':=> differential assign" in {check(assignDAxiom)}
  it should "tactically prove <++> choice" in {check(choicedAxiom)}
  it should "tactically prove <;> compose" in {check(composedAxiom)}
  it should "tactically prove <*> iterate" in {check(iteratedAxiom)}
  it should "tactically prove exists generalize" in {check(existsGeneralize)}
  it should "tactically prove = reflexive" in withMathematica { qeTool => check(equalReflex)}
  it should "tactically prove = commute" in withMathematica { qeTool => check(equalCommute)}
  it should "tactically prove <=" in withMathematica { qeTool => check(lessEqual)}
  it should "tactically prove ! !=" in withMathematica { qeTool => check(notNotEqual)}
  it should "tactically prove ! >=" in withMathematica { qeTool => check(notGreaterEqual)}
  it should "tactically prove >= flip" in withMathematica { qeTool => check(flipGreaterEqual)}
  it should "tactically prove > flip" in withMathematica { qeTool => check(flipGreater)}
  it should "tactically prove all substitute" in {check(allSubstitute)}
  it should "tactically prove vacuous exists" in {check(vacuousExistsAxiom)}
  it should "tactically prove V[:*] vacuous assign nondet" in {check(vacuousBoxAssignNondetAxiom)}
  it should "tactically prove V<:*> vacuous assign nondet" in {check(vacuousDiamondAssignNondetAxiom)}
  it should "tactically prove \\forall->\\exists" in {check(forallThenExistsAxiom)}
  //it should "tactically prove DI differential invariance" in {check(DIinvariance)}
  it should "tactically prove DI differential invariant" in {check(DIinvariant)}
  it should "tactically prove DG differential pre-ghost" in {check(DGpreghost)}
  it should "tactically prove DW differential weakening" in {check(DWeakening)}
  it should "tactically prove abs" in withMathematica { qeTool => check(absDef)}
  it should "tactically prove min" in withMathematica { qeTool => check(minDef)}
  it should "tactically prove max" in withMathematica { qeTool => check(maxDef)}

  "Mathematica" should "derive compatibility axiom dgZeroEquilibrium" in withMathematica { qeTool =>
    import TactixLibrary._
    val dgZeroEquilibrium = AxiomInfo.ofCodeName("dgZeroEquilibrium")
    dgZeroEquilibrium.formula shouldBe "x=0 & n>0 -> [{x'=c*x^n}]x=0".asFormula

    TactixLibrary.proveBy(dgZeroEquilibrium.formula,
      implyR(1) & dG("y' = ( (-c*x^(n-1)) / 2)*y".asDifferentialProgram, Some("x*y^2=0&y>0".asFormula))(1) &
      TactixLibrary.boxAnd(1, 0::Nil) &
      DifferentialTactics.diffInd()(1, 0::0::Nil) &
      dG("z' = (c*x^(n-1)/4) * z".asDifferentialProgram, Some("y*z^2 = 1".asFormula))(1, 0::1::Nil) &
      dI()(1, 0::1::0::Nil) & QE
    ) shouldBe 'proved
  }

  "SimplifierV3" should "prove * identity neg" in {check{timesIdentityNeg}}
  it should "prove -0" in {check{minusZero}}
  it should "prove 0-" in {check{zeroMinus}}
  it should "prove >0 -> !=0"  in {check{gtzImpNez}}
  it should "prove <0 -> !=0"  in {check{ltzImpNez}}
  it should "prove !=0 -> 0/F" in {check{zeroDivNez}}
  it should "prove F^0" in {check{powZero}}
  it should "prove F^1"        in {check{powOne}}

  it should "prove < irrefl" in {check{lessNotRefl}}
  it should "prove > irrefl" in {check{greaterNotRefl}}
  it should "prove != irrefl" in {check{notEqualNotRefl}}
  it should "prove = refl"  in {check{equalRefl}}
  it should "prove <= refl"  in {check{lessEqualRefl}}
  it should "prove >= refl"  in {check{greaterEqualRefl}}

  it should "prove = sym"  in {check{equalSym}}
  it should "prove != sym"  in {check{equalSym}}
  it should "prove > antisym"  in {check{greaterNotSym}}
  it should "prove < antisym"  in {check{lessNotSym}}
}
